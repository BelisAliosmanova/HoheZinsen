<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interest Rate Offers</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/css/styles.css">
</head>
<body class="bg-light">
<div class="container py-4">

    <div class="d-flex justify-content-between align-items-center mb-4 flex-wrap">
        <div class="d-flex align-items-center flex-wrap">
            <h2 class="me-3 mb-2 mb-md-0">Interest Rate Offers</h2>
            <span class="order-changed-indicator" id="orderChangedIndicator">
                Order changed - click save to persist
            </span>
            <button class="save-order-btn" id="saveOrderBtn" onclick="saveColumnOrder()">
                Save Order
            </button>
        </div>
        <a class="btn btn-primary mt-2 mt-md-0" href="/interest-rate/new">+ Add New Interest Rate</a>
    </div>

    <!-- Form to Add a New Global Field -->
    <form class="mb-4" method="post" th:action="@{/fields/add}" th:object="${newField}">
        <div class="row g-2">
            <div class="col-md-6 col-lg-4">
                <input class="form-control" placeholder="Label (e.g. Max Deposit)" th:field="*{label}"/>
            </div>
            <div class="col-md-6 col-lg-4">
                <button class="btn btn-primary w-100">Add Field</button>
            </div>
        </div>
    </form>

    <!-- View Toggle for Mobile -->
    <div class="view-toggle d-md-none">
        <div class="btn-group" role="group" aria-label="View toggle">
            <button type="button" class="btn btn-outline-primary active" id="stackedView">
                üì± Card View
            </button>
            <button type="button" class="btn btn-outline-primary" id="scrollView">
                üìä Table View
            </button>
        </div>
    </div>

    <div class="table-container">
        <div class="table-responsive" id="tableContainer">
            <table class="table table-sm" id="mainTable">
                <thead class="table">
                <tr id="column-header-row">
                    <th class="draggable-column sortable"
                        draggable="true"
                        ondragend="handleDragEnd(event)"
                        ondragover="handleDragOver(event)"
                        ondragstart="handleDragStart(event)"
                        ondrop="handleDrop(event)"
                        onclick="sortTable(this, event)"
                        th:data-field-id="${field.id}"
                        th:data-column-index="${iterStat.index}"
                        th:each="field, iterStat : ${globalFields}">

                        <div class="drag-handle">‚ãÆ‚ãÆ</div>

                        <div class="header-container">
                            <span class="header-text" th:text="${field.label}"></span>
                            <button class="edit-header-btn" th:onclick="'showEditForm(' + ${field.id} + ')'" type="button">
                                ‚úé
                            </button>
                            <button class="delete-field-btn"
                                    th:data-id="${field.id}"
                                    th:data-label="${field.label}"
                                    onclick="handleFieldDeleteClick(this)"
                                    type="button"
                                    title="Delete this field">
                                üóë
                            </button>

                            <!-- Edit Form -->
                            <div class="header-edit-form" th:id="'editForm_' + ${field.id}">
                                <form method="post" th:action="@{/fields/update}">
                                    <input name="fieldId" th:value="${field.id}" type="hidden"/>

                                    <div class="form-row">
                                        <label>Display Label:</label>
                                        <input name="label" required th:value="${field.label}" type="text"/>
                                    </div>

                                    <div class="form-buttons">
                                        <button class="save-btn" type="submit">Save</button>
                                        <button class="cancel-btn" th:onclick="'hideEditForm(' + ${field.id} + ')'"
                                                type="button">Cancel
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    </th>
                    <th class="no-drag">Actions</th>
                </tr>
                </thead>

                <tbody>
                <tr th:each="rate : ${interestRates}">
                    <!-- Dynamic fields -->
                    <td class="data-cell"
                        th:data-field-id="${field.id}"
                        th:data-label="${field.label}"
                        th:each="field : ${globalFields}">
                        <form class="d-flex justify-content-center" method="post" th:action="@{/field-values/update}">
                            <input name="rateId" th:value="${rate.id}" type="hidden"/>
                            <input name="fieldId" th:value="${field.id}" type="hidden"/>
                            <input class="form-control form-control-sm text-center"
                                   name="value"
                                   th:value="${rateFieldValuesMap[rate.id]?.get(field.id)}"
                                   type="text"/>
                        </form>
                    </td>

                    <!-- Actions -->
                    <td data-label="Actions">
                        <div class="action-buttons">
                            <button class="mehr-info-btn"
                                    th:disabled="${rate.moreInfo == null}"
                                    th:onclick="'showMoreInfo(' + ${rate.id} + ')'"
                                    th:text="${rate.moreInfo != null ? 'MEHR INFO' : 'No Info'}">
                            </button>

                            <a class="btn-edit" th:href="@{/interest-rate/edit/{id}(id=${rate.id})}" title="Edit Interest Rate">
                                ‚úé Edit
                            </a>

                            <button class="btn-delete"
                                    th:onclick="'showDeleteConfirmation(' + ${rate.id} + ')'"
                                    title="Delete Interest Rate">
                                üóë Delete
                            </button>
                        </div>
                    </td>
                </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- Keep all your existing modals and notifications -->
<!-- Field Delete Confirmation Modal -->
<div class="delete-confirmation-modal" id="fieldDeleteConfirmationModal">
    <div class="delete-confirmation-content">
        <h5>‚ö†Ô∏è Delete Field</h5>
        <div class="field-info">
            <p><strong>Field:</strong> <span id="fieldToDeleteName">Field Name</span></p>
            <p><strong>ID:</strong> <span id="fieldToDeleteId">Field ID</span></p>
        </div>
        <p>Are you sure you want to delete this field (column)?</p>
        <div class="warning-text">
            ‚ö†Ô∏è This will permanently remove the field and ALL associated data for every interest rate!
        </div>
        <p><strong>This action cannot be undone.</strong></p>

        <div class="delete-confirmation-buttons">
            <button class="btn btn-danger" id="confirmFieldDeleteBtn">Yes, Delete Field</button>
            <button class="btn btn-secondary" onclick="hideFieldDeleteConfirmation()">Cancel</button>
        </div>
    </div>
</div>

<!-- Interest Rate Delete Confirmation Modal -->
<div class="delete-confirmation-modal" id="deleteConfirmationModal">
    <div class="delete-confirmation-content">
        <h5>‚ö†Ô∏è Confirm Deletion</h5>
        <p>Are you sure you want to delete this interest rate?</p>
        <p><strong>This action cannot be undone.</strong></p>

        <div class="delete-confirmation-buttons">
            <button class="btn btn-danger" id="confirmDeleteBtn">Yes, Delete</button>
            <button class="btn btn-secondary" onclick="hideDeleteConfirmation()">Cancel</button>
        </div>
    </div>
</div>

<!-- Drop indicator -->
<div class="drop-indicator" id="dropIndicator"></div>

<!-- Delete notification -->
<div class="delete-notification" id="deleteNotification">
    Action completed successfully!
</div>

<!-- Include jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

<script th:inline="javascript">
    // Keep ALL your existing JavaScript exactly as it was
    const interestRatesData = /*[[${interestRates}]]*/ [];

    let currentExpandedCard = null;
    let currentEditForm = null;
    let draggedElement = null;
    let orderChanged = false;
    let originalOrder = [];
    let pendingDeleteId = null;
    let pendingFieldDeleteId = null;
    let draggedSection = null;
    let currentRateId = null;
    let dataTable = null; // Remove DataTable reference
    let currentSortColumn = null;
    let currentSortDirection = null;

    document.addEventListener('DOMContentLoaded', function () {
        captureOriginalOrder();
        initializeSortableHeaders();
        initializeResponsiveToggle();
    });

    function initializeResponsiveToggle() {
        const stackedViewBtn = document.getElementById('stackedView');
        const scrollViewBtn = document.getElementById('scrollView');
        const tableContainer = document.getElementById('tableContainer');

        if (stackedViewBtn && scrollViewBtn) {
            stackedViewBtn.addEventListener('click', function() {
                tableContainer.classList.add('mobile-stack');
                stackedViewBtn.classList.add('active');
                scrollViewBtn.classList.remove('active');
            });

            scrollViewBtn.addEventListener('click', function() {
                tableContainer.classList.remove('mobile-stack');
                scrollViewBtn.classList.add('active');
                stackedViewBtn.classList.remove('active');
            });

            // Set default view for mobile
            if (window.innerWidth <= 768) {
                tableContainer.classList.add('mobile-stack');
            }
        }
    }

    function initializeSortableHeaders() {
        // Add sortable class to all draggable columns
        const headers = document.querySelectorAll('.draggable-column');
        headers.forEach(header => {
            header.classList.add('sortable');
        });
    }

    function sortTable(headerElement, event) {
        // Prevent drag events from interfering
        if (event && event.type === 'click' && headerElement.classList.contains('dragging')) {
            return;
        }

        const columnIndex = parseInt(headerElement.dataset.columnIndex);
        const table = document.getElementById('mainTable');
        const tbody = table.getElementsByTagName('tbody')[0];
        const rows = Array.from(tbody.getElementsByTagName('tr'));

        // Determine sort direction
        let sortDirection = 'asc';
        if (currentSortColumn === columnIndex) {
            sortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
        }

        // Clear previous sort indicators
        document.querySelectorAll('.sortable').forEach(th => {
            th.classList.remove('sort-asc', 'sort-desc');
        });

        // Add sort indicator to current column
        headerElement.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');

        // Sort rows
        rows.sort((a, b) => {
            const aCell = a.getElementsByTagName('td')[columnIndex];
            const bCell = b.getElementsByTagName('td')[columnIndex];

            let aValue = '';
            let bValue = '';

            // Get the value from input if exists, otherwise use text content
            const aInput = aCell.querySelector('input[name="value"]');
            const bInput = bCell.querySelector('input[name="value"]');

            if (aInput && bInput) {
                aValue = aInput.value || '';
                bValue = bInput.value || '';
            } else {
                aValue = aCell.textContent.trim();
                bValue = bCell.textContent.trim();
            }

            // Try to parse as numbers for numeric sorting
            const aNum = parseFloat(aValue);
            const bNum = parseFloat(bValue);

            if (!isNaN(aNum) && !isNaN(bNum)) {
                return sortDirection === 'asc' ? aNum - bNum : bNum - aNum;
            } else {
                // String comparison
                return sortDirection === 'asc'
                    ? aValue.localeCompare(bValue)
                    : bValue.localeCompare(aValue);
            }
        });

        // Re-append sorted rows
        rows.forEach(row => tbody.appendChild(row));

        // Update current sort state
        currentSortColumn = columnIndex;
        currentSortDirection = sortDirection;

        // Update sort info
        updateSortInfo(headerElement.textContent.trim(), sortDirection);
    }

    function updateSortInfo(columnName, direction) {
        const sortInfo = document.getElementById('sortInfo');
        if (sortInfo) {
            if (columnName && direction) {
                sortInfo.innerHTML = `Sorted by: <strong>${columnName}</strong> ${direction === 'asc' ? '‚Üë' : '‚Üì'}`;
                sortInfo.style.background = 'linear-gradient(135deg, #e7f3ff, #cce7ff)';
            } else {
                sortInfo.textContent = 'Click column headers to sort ‚ÜïÔ∏è';
                sortInfo.style.background = 'white';
            }
        }
    }

    function resetSort() {
        // Clear all sort indicators
        document.querySelectorAll('.sortable').forEach(th => {
            th.classList.remove('sort-asc', 'sort-desc');
        });

        // Reset sort state
        currentSortColumn = null;
        currentSortDirection = null;

        // Update sort info
        updateSortInfo();

        // Reload the page to restore original order (or implement your own logic)
        showDeleteNotification('Sort reset! Reload page to restore original order.', false);
    }

    // Keep all your existing functions but add DataTable integration where needed
    function captureOriginalOrder() {
        const headers = document.querySelectorAll('.draggable-column');
        originalOrder = Array.from(headers)
            .map(header => header.dataset.fieldId);
    }

    function handleFieldDeleteClick(button) {
        const fieldId = button.dataset.id;
        const fieldLabel = button.dataset.label;
        showFieldDeleteConfirmation(fieldId, fieldLabel);
    }

    function showFieldDeleteConfirmation(fieldId, fieldLabel) {
        pendingFieldDeleteId = fieldId;
        document.getElementById('fieldToDeleteName')
            .textContent = fieldLabel;
        document.getElementById('fieldToDeleteId')
            .textContent = fieldId;
        document.getElementById('fieldDeleteConfirmationModal')
            .style.display = 'flex';

        document.getElementById('confirmFieldDeleteBtn')
            .onclick = function () {
                deleteGlobalField(fieldId);
            };
    }

    function hideFieldDeleteConfirmation() {
        document.getElementById('fieldDeleteConfirmationModal')
            .style.display = 'none';
        pendingFieldDeleteId = null;
    }

    function deleteGlobalField(fieldId) {
        const confirmBtn = document.getElementById('confirmFieldDeleteBtn');
        const originalText = confirmBtn.textContent;
        confirmBtn.textContent = 'Deleting...';
        confirmBtn.disabled = true;

        fetch(`/fields/delete/${fieldId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to delete field');
                }
                return response.text();
            })
            .then(data => {
                hideFieldDeleteConfirmation();

                showDeleteNotification('Field deleted successfully! Page will reload...', false);

                setTimeout(() => {
                    window.location.reload();
                }, 1500);
            })
            .catch(error => {
                // Reset button
                confirmBtn.textContent = originalText;
                confirmBtn.disabled = false;

                showDeleteNotification('Error deleting field: ' + error.message, true);
            });
    }

    // Interest rate delete functionality
    function showDeleteConfirmation(rateId) {
        pendingDeleteId = rateId;
        document.getElementById('deleteConfirmationModal')
            .style.display = 'flex';

        // Set up the confirm button click handler
        document.getElementById('confirmDeleteBtn')
            .onclick = function () {
                deleteInterestRate(rateId);
            };
    }

    function hideDeleteConfirmation() {
        document.getElementById('deleteConfirmationModal')
            .style.display = 'none';
        pendingDeleteId = null;
    }

    function deleteInterestRate(rateId) {
        fetch(`/interest-rate/${rateId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to delete interest rate');
                }
                return response.text();
            })
            .then(data => {
                // Hide the confirmation modal
                hideDeleteConfirmation();

                // Show success notification
                showDeleteNotification('Interest rate deleted successfully!', false);

                // Remove the row from the table
                removeInterestRateRow(rateId);

                // Close any expanded card for this rate
                closeExpandedCard(rateId);
            })
            .catch(error => {
                hideDeleteConfirmation();
                showDeleteNotification('Error deleting interest rate: ' + error.message, true);
            });
    }

    function removeInterestRateRow(rateId) {
        // Find and remove the main table row
        const tableRows = document.querySelectorAll('#mainTable tbody tr');
        tableRows.forEach(row => {
            const rateIdInput = row.querySelector('input[name="rateId"]');
            if (rateIdInput && rateIdInput.value == rateId) {
                row.remove();
            }
        });

        // Remove from interestRatesData array
        const index = interestRatesData.findIndex(rate => rate.id === rateId);
        if (index > -1) {
            interestRatesData.splice(index, 1);
        }
    }

    function showDeleteNotification(message, isError) {
        const notification = document.getElementById('deleteNotification');
        notification.textContent = message;
        notification.classList.toggle('error', isError);
        notification.classList.toggle('success', !isError);
        notification.classList.add('show');

        setTimeout(() => {
            notification.classList.remove('show');
        }, 3000);
    }

    // Close modals when clicking outside
    document.getElementById('deleteConfirmationModal')
        .addEventListener('click', function (e) {
            if (e.target === this) {
                hideDeleteConfirmation();
            }
        });

    document.getElementById('fieldDeleteConfirmationModal')
        .addEventListener('click', function (e) {
            if (e.target === this) {
                hideFieldDeleteConfirmation();
            }
        });

    // Column drag and drop functionality
    function handleDragStart(event) {
        draggedElement = event.target;
        event.target.classList.add('dragging');
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/html', event.target.outerHTML);
    }

    function handleDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';

        const target = event.target.closest('.draggable-column');
        if (target && target !== draggedElement) {
            // Remove existing drag-over class
            document.querySelectorAll('.drag-over')
                .forEach(el => el.classList.remove('drag-over'));
            target.classList.add('drag-over');

            // Show drop indicator
            showDropIndicator(target, event);
        }
    }

    function handleDrop(event) {
        event.preventDefault();

        const target = event.target.closest('.draggable-column');
        if (target && target !== draggedElement) {
            const draggedFieldId = draggedElement.dataset.fieldId;
            const targetFieldId = target.dataset.fieldId;

            // Move the column
            moveColumn(draggedFieldId, targetFieldId);

            // Mark order as changed
            markOrderChanged();
        }

        // Clean up
        cleanup();
    }

    function handleDragEnd(event) {
        cleanup();
    }

    function cleanup() {
        if (draggedElement) {
            draggedElement.classList.remove('dragging');
        }
        document.querySelectorAll('.drag-over')
            .forEach(el => el.classList.remove('drag-over'));
        hideDropIndicator();
        draggedElement = null;
    }

    function moveColumn(draggedFieldId, targetFieldId) {
        const headerRow = document.getElementById("column-header-row");
        const headers = Array.from(headerRow.querySelectorAll(".draggable-column"));

        const draggedIndex = headers.findIndex(h => h.dataset.fieldId === draggedFieldId);
        const targetIndex = headers.findIndex(h => h.dataset.fieldId === targetFieldId);

        if (draggedIndex === -1 || targetIndex === -1 || draggedIndex === targetIndex) return;

        // Move header
        const draggedHeader = headers[draggedIndex];
        if (targetIndex < draggedIndex) {
            headerRow.insertBefore(draggedHeader, headers[targetIndex]);
        } else {
            headerRow.insertBefore(draggedHeader, headers[targetIndex].nextSibling);
        }

        // Move data cells for each row
        const rows = document.querySelectorAll("#mainTable tbody tr");
        rows.forEach(row => {
            const cells = Array.from(row.querySelectorAll(".data-cell"));
            const draggedCell = cells[draggedIndex];
            if (!draggedCell) return;

            if (targetIndex < draggedIndex) {
                row.insertBefore(draggedCell, cells[targetIndex]);
            } else {
                row.insertBefore(draggedCell, cells[targetIndex].nextSibling);
            }
        });
    }

    function markOrderChanged() {
        orderChanged = true;
        document.getElementById("saveOrderBtn")
            .classList.add("show");
        document.getElementById("orderChangedIndicator")
            .classList.add("show");
    }

    function saveColumnOrder() {
        const headers = document.querySelectorAll(".draggable-column");
        const newOrder = Array.from(headers)
            .map(header => header.dataset.fieldId);

        fetch('/fields/reorder', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': getCsrfToken()
                },
                body: JSON.stringify(newOrder)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error("Failed to save order");
                }
                return response.text();
            })
            .then(data => {
                orderChanged = false;
                document.getElementById("saveOrderBtn")
                    .classList.remove("show");
                document.getElementById("orderChangedIndicator")
                    .classList.remove("show");
                console.log(data);
            })
            .catch(error => {
                alert("Error saving order: " + error.message);
            });
    }

    // Optional: CSRF token extraction if needed for Spring Security
    function getCsrfToken() {
        const tokenMeta = document.querySelector('meta[name="_csrf"]');
        return tokenMeta ? tokenMeta.getAttribute('content') : '';
    }

    function showDropIndicator(target, event) {
        const indicator = document.getElementById("dropIndicator");
        const rect = target.getBoundingClientRect();
        indicator.style.left = `${rect.left}px`;
        indicator.style.top = `${rect.top}px`;
        indicator.style.height = `${rect.height}px`;
        indicator.classList.add("show");
    }

    function hideDropIndicator() {
        document.getElementById("dropIndicator")
            .classList.remove("show");
    }

    // Section drag and drop functions - FIXED VERSION
    function handleSectionDragStart(event, sectionIdentifier, rateId) {
        draggedSection = {
            element: event.target.closest('.expanded-section'),
            identifier: sectionIdentifier,
            rateId: rateId
        };
        draggedSection.element.classList.add('dragging');
        currentRateId = rateId;
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', sectionIdentifier);
    }

    function handleSectionDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';

        const target = event.target.closest('.expanded-section');
        if (target && draggedSection && target !== draggedSection.element &&
            target.closest(`#rateCard_${currentRateId}`)) {

            // Remove existing drag-over class
            document.querySelectorAll('.drag-over')
                .forEach(el => el.classList.remove('drag-over'));
            target.classList.add('drag-over');
        }
    }

    function handleSectionDrop(event, targetIdentifier, rateId) {
        event.preventDefault();

        if (draggedSection && draggedSection.rateId === rateId && draggedSection.identifier !== targetIdentifier) {
            const sourceElement = draggedSection.element;
            const targetElement = event.target.closest('.expanded-section');

            if (sourceElement && targetElement) {
                // Get the parent container (should be the rate card content)
                const parent = sourceElement.parentElement;

                // Determine if we should insert before or after the target
                const sourceIndex = Array.from(parent.children)
                    .indexOf(sourceElement);
                const targetIndex = Array.from(parent.children)
                    .indexOf(targetElement);

                if (sourceIndex < targetIndex) {
                    // Moving down - insert after target
                    parent.insertBefore(sourceElement, targetElement.nextSibling);
                } else {
                    // Moving up - insert before target
                    parent.insertBefore(sourceElement, targetElement);
                }

                // Get new order from DOM - only count sections with data-section-id
                const sections = parent.querySelectorAll('[data-section-id]');
                const newOrder = Array.from(sections)
                    .map(el => el.getAttribute('data-section-id'));

                // Update the order in the database
                saveSectionOrder(rateId, newOrder);
            }
        }

        // Clean up
        cleanupSectionDrag();
    }

    function handleSectionDragEnd(event) {
        cleanupSectionDrag();
    }

    function cleanupSectionDrag() {
        if (draggedSection && draggedSection.element) {
            draggedSection.element.classList.remove('dragging');
        }
        document.querySelectorAll('.drag-over')
            .forEach(el => el.classList.remove('drag-over'));
        draggedSection = null;
        currentRateId = null;
    }

    // Save section order - single implementation
    function saveSectionOrder(rateId, newOrder) {
        fetch(`/sections/reorder?rateId=${rateId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(newOrder)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error("Failed to save section order");
                }
                return response.text();
            })
            .catch(error => {
                showSectionOrderNotification("Error saving section order: " + error.message, true);
            });
    }


    function showMoreInfo(rateId) {
        const rate = interestRatesData.find(r => r.id === rateId);
        if (!rate || !rate.moreInfo) return;

        // Close any currently expanded card
        if (currentExpandedCard && currentExpandedCard !== rateId) {
            closeExpandedCard(currentExpandedCard);
        }

        // Check if card already exists
        let existingCard = document.getElementById(`rateCard_${rateId}`);
        if (existingCard) {
            existingCard.remove();
            if (currentExpandedCard === rateId) {
                currentExpandedCard = null;
                return;
            }
        }

        // Find the table row that was clicked
        const tableRows = document.querySelectorAll('tbody tr');
        let targetRow = null;

        tableRows.forEach(row => {
            const button = row.querySelector('.mehr-info-btn');
            if (button && button.onclick && button.onclick.toString()
                .includes(`showMoreInfo(${rateId})`)) {
                targetRow = row;
            }
        });

        if (!targetRow) return;

        // Create new card
        const card = createRateCard(rate);

        // Create a new table row to hold the card
        const cardRow = document.createElement('tr');
        cardRow.id = `rateCardRow_${rateId}`;
        cardRow.innerHTML = `<td colspan="100%" style="padding: 0; background: transparent;"></td>`;

        // Insert the card into the cell
        cardRow.firstChild.appendChild(card);

        // Insert the card row after the clicked row
        targetRow.parentNode.insertBefore(cardRow, targetRow.nextSibling);

        // Scroll to the card
        card.scrollIntoView({
            behavior: 'smooth',
            block: 'center'
        });

        currentExpandedCard = rateId;
    }

    function createRateCard(rate) {
        const card = document.createElement('div');
        card.className = 'rate-card';
        card.id = `rateCard_${rate.id}`;

        const moreInfo = rate.moreInfo;
        if (!moreInfo) return card;

        // Get the section order from the data, default to empty array
        const sectionOrder = moreInfo.sectionOrder || [];

        // Create section content maps
        const tableSectionsMap = new Map();
        const textSectionsMap = new Map();

        // Map table sections by identifier
        if (moreInfo.tableSections) {
            moreInfo.tableSections.forEach(tableSection => {
                tableSectionsMap.set(tableSection.sectionIdentifier, tableSection);
            });
        }

        // Map text sections by identifier
        if (moreInfo.textSections) {
            moreInfo.textSections.forEach(textSection => {
                textSectionsMap.set(textSection.sectionIdentifier, textSection);
            });
        }

        // Helper function to create table sections
        const createTableSection = (tableSection) => {
            if (!tableSection || !tableSection.title || !tableSection.miniTableRows || tableSection.miniTableRows.length === 0) {
                return '';
            }
            return `
                    <div class="expanded-section draggable-section table-section"
                         draggable="true"
                         data-section-type="table"
                         data-section-id="${tableSection.sectionIdentifier}"
                         ondragstart="handleSectionDragStart(event, '${tableSection.sectionIdentifier}', ${rate.id})"
                         ondragover="handleSectionDragOver(event)"
                         ondrop="handleSectionDrop(event, '${tableSection.sectionIdentifier}', ${rate.id})"
                         ondragend="handleSectionDragEnd(event)">
                        <div class="section-drag-handle" title="Drag to reorder">‚ãÆ‚ãÆ</div>
                        <div class="section-controls">
                            <span class="section-type-indicator">Table</span>
                        </div>
                        <h5 class="section-title">${tableSection.title}</h5>
                        <div class="info-table">
                            ${tableSection.miniTableRows.map(row => `
                                <div class="info-table-row">
                                    <div class="info-table-label">${row.label || ''}</div>
                                    <div class="info-table-value">${row.description || ''}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
        };

        // Helper function to create text sections
        const createTextSection = (textSection) => {
            if (!textSection || (!textSection.title && !textSection.content)) {
                return '';
            }
            return `
                    <div class="expanded-section draggable-section text-section"
                         draggable="true"
                         data-section-type="text"
                         data-section-id="${textSection.sectionIdentifier}"
                         ondragstart="handleSectionDragStart(event, '${textSection.sectionIdentifier}', ${rate.id})"
                         ondragover="handleSectionDragOver(event)"
                         ondrop="handleSectionDrop(event, '${textSection.sectionIdentifier}', ${rate.id})"
                         ondragend="handleSectionDragEnd(event)">
                        <div class="section-drag-handle" title="Drag to reorder">‚ãÆ‚ãÆ</div>
                        <div class="section-controls">
                            <span class="section-type-indicator">Text</span>
                        </div>
                        ${textSection.title ? `<h5 class="section-title">${textSection.title}</h5>` : ''}
                        <div class="text-content" style="text-align: left;">${textSection.content || ''}</div>
                    </div>
                `;
        };

        // Build sections in the correct order
        let sectionsHTML = '';
        sectionOrder.forEach(sectionIdentifier => {
            if (sectionIdentifier.startsWith('table-')) {
                const tableSection = tableSectionsMap.get(sectionIdentifier);
                if (tableSection) {
                    sectionsHTML += createTableSection(tableSection);
                }
            } else if (sectionIdentifier.startsWith('text-')) {
                const textSection = textSectionsMap.get(sectionIdentifier);
                if (textSection) {
                    sectionsHTML += createTextSection(textSection);
                }
            }
        });

        // Add any sections not in the order (fallback)
        tableSectionsMap.forEach((tableSection, identifier) => {
            if (!sectionOrder.includes(identifier)) {
                sectionsHTML += createTableSection(tableSection);
            }
        });

        textSectionsMap.forEach((textSection, identifier) => {
            if (!sectionOrder.includes(identifier)) {
                sectionsHTML += createTextSection(textSection);
            }
        });

        card.innerHTML = `
                <div class="rate-expanded-content show">
                    ${sectionsHTML}
                </div>
            `;

        return card;
    }

    function closeExpandedCard(rateId) {
        const cardRow = document.getElementById(`rateCardRow_${rateId}`);
        if (cardRow) {
            cardRow.remove();
            if (currentExpandedCard === rateId) {
                currentExpandedCard = null;
            }
        }
    }

    // Show/hide edit form logic
    function showEditForm(fieldId) {
        if (currentEditForm) {
            currentEditForm.classList.remove('show');
        }
        const form = document.getElementById('editForm_' + fieldId);
        if (form) {
            form.classList.add('show');
            currentEditForm = form;
        }
    }

    function hideEditForm(fieldId) {
        const form = document.getElementById('editForm_' + fieldId);
        if (form) {
            form.classList.remove('show');
        }
        currentEditForm = null;
    }

    // Handle outside click to close header edit form
    document.addEventListener('click', function (e) {
        if (currentEditForm && !currentEditForm.contains(e.target) && !e.target.classList.contains('edit-header-btn')) {
            currentEditForm.classList.remove('show');
            currentEditForm = null;
        }
    });

    // Handle window resize to update responsive view
    window.addEventListener('resize', function() {
        const tableContainer = document.getElementById('tableContainer');
        const stackedViewBtn = document.getElementById('stackedView');
        const scrollViewBtn = document.getElementById('scrollView');

        if (window.innerWidth > 768) {
            // Desktop view - remove mobile classes
            tableContainer.classList.remove('mobile-stack');
            if (stackedViewBtn) stackedViewBtn.style.display = 'none';
            if (scrollViewBtn) scrollViewBtn.style.display = 'none';
        } else {
            // Mobile view - show toggle buttons
            if (stackedViewBtn) stackedViewBtn.style.display = 'inline-block';
            if (scrollViewBtn) scrollViewBtn.style.display = 'inline-block';

            // Default to stacked view on mobile if not already set
            if (!tableContainer.classList.contains('mobile-stack') &&
                stackedViewBtn && stackedViewBtn.classList.contains('active')) {
                tableContainer.classList.add('mobile-stack');
            }
        }
    });
</script>
</body>
</html>